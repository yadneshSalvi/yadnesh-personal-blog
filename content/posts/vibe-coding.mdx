---
title: "Vibe-coding: What works and what doesn't"
subtitle: "As of August 2025"
image: "/vibecoding.png"
createdAt: "2025-08-20T15:19:00.000Z"
updatedAt: "2025-08-20T15:19:00.000Z"
tags: ["Vibe-coding"]
readingTime: 5
---

## Origins

Andrej Karpathy coined the term "vibe coding" in one of his tweets. It's a new kind of coding where you just "see stuff, say stuff, run stuff, and copy paste stuff, and it mostly works". So you are not really writing the code yourself, you leave that task for the supreme LLMs.

<Tweet id="1886192184808149383" />

## Present

It's been more than six months since Karpath's tweet and the "vibe-coding" fever is still high.

Lots of tools have come which help devs to vibecode. Some of the tools I use currently and found useful are Cursor, Lovable for building UI, Claude Code and sometimes Warp.

There are many more, but if you use a few others are just the same, with different ways of orchestraion and llm models.

### When Vibe-coding doesn't work?

This site for example was completely made with vibe-coding. 

I do have some understanding of javascript, typescript, react and nextjs, but I'm very new to it. I come from AI/ML, and python development background. So I have largely relied on LLMs for writing most of the code.

This site was not made in first attempt. 

I made several iterations using lovable, discarded them. Then made several attempts using cursor, didn't like discarded. Same with Warp and Claude code.

Here's what I was doing wrong and didn't work.

#### Creating a long detailed plan and giving to LLM

I knew exactly what I wanted to build. 

I would describe each page in detail, each functionality in detail and hand it over to LLM, and hope that the generated code worked. 

Lovable was the closest one, but it didn't fully work. And if you plan to give such a big detailed task to cursor then forget it, it will never work (as of today).

#### Fixing things on large codebase

The first step would often result in LLM writing a lot of code. And many things wouldn't work in it. 

For example, one important thing for any coding blog is the ability to embed code snippets. Sometimes, syntax highlighting didn't work in the LLM generated code. Which is not a good thing for a coding blog. So I would ask it politely "please fix syntax highlighting", ofcourse with much more context where possible. It would agree, and then do a lot of searching, fixing, and say "Try now it will work!". But sadly it didn't. And when things continued down this path, it would delete large parts of code base, rewrite them completely, use different libraries while removing existing ones, and of course this made things worse. Often things that worked already would also start breaking. If you didn't use git, it was a nightmare.

<Callout type="tip">
Always use git while vibe-coding, and keep commiting changes that work. So that you can safely discard the LLM generated mess, when it does not work.
</Callout>

The only time fixing things on large codebase while vibe-coding might work, is when you understand the code yourself and can guide the LLM well to fix it.

#### Vague prompts without a plan

If you prompt LLM to "Build a SaaS application helps users trade Bitcoins", sure the LLM will build something. And it will be very exciting to watch. But chances are it won't work. And it won't be production ready for sure.

<Callout type="error" title="Danger">
Don't try to one-shot vibe-coded applications, unless there's some sophisticated Agentic system involved, or we have achieved AGI.
</Callout>

### When Vibe-coding works?

Well this site is ready and up, so vibe-coding does work.

Here are some tips to make it work.

#### Start with the most important functionality first

In my case since I wanted to create a personal tech blog, the most important functionality was the blog itself.

So I started with creating the blog, with just one instruction to include code snippets in it.


#### Proceed in small steps

Even when building the most important functionality first, don't try to build the entire functionality in one go, try to break it into steps, and build iteratively.

Once code snippets worked well in my blog, I asked LLM to add support for embedding tweets, then for callout blocks, then the side bar for table of content, and so on. ONE AT A TIME. 

Testing each time if the code worked or not. If it worked push the changes to git repo. If not help LLM with exact errors in terminal and console and get them fixed. Since this is a small task at a time LLM usually does a good job of fixing the error.

#### Add functionality gradually

I knew from start that there needs to be an "About" page, a "Contact" page, "Search" functionality and so on.

But avoid asking LLM to build everything at once. First just build the "About" page, add any functionality you want. Once completed commit it, then move to next page.

#### Use good LLM models

I personally use claude-sonnet-4 a lot. GPT-5 which came out recently is turning out to be better than claude-sonnet-4, and I might switch to it next, but even Anthropic has come up with 4.1 models which will be interesting to try.

Avoid using very old models like gpt-4o or claude-3 as they will not perform that well, unless your tasks are trivial or you know what you are doing.

## Future

Will coders become absolute as vibe-coding keeps getting better?

### Calculator Analogy

Calculator did not make mathematicians obsolete. But sure it made everyone better at math and made it fear math lesser.

If I want to multiply two big numbers, I can do it with pen and paper, but I'd prefer to user calculator as a tool to get it done quickly.

I look at vibe-coding at same way. I love the AI-assisted coding platforms, and they are making everyone more productive for sure.

### Flaw in Calculator Analogy

Comparing AI-assisted coding to calculator, isn't the same as comparing apples to apples.

The most important distinction is that calculator has limited functionality, and it works 100% accurately everytime.

LLMs have infinite knowledge and functionaliy, but they can never be 100% accurate, due to their probabilistic next token generation mechanism.

So while I don't see LLMs replacing coders as of the next few years, but coders having good domain knowledge who are using AI-assisted tools, will replace ones not using them, by being more productive, for sure.

I would like to end, the blog with Andrew Ng's answer on job opportunities for coders in an AI world. (Go to 19:06 in video timeline, if it doesn't go on its own, after all it's vibe coded ;))

<YouTube id="ckS-ynViLjY" start={1146} params="end=1304" title="Andrew Ng & Lisa Su on AI potential" poster="hqdefault" />